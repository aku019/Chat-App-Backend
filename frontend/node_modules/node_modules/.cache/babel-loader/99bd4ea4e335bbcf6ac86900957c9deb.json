{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useQuery(query, options) {\n  var _a;\n\n  var context = useContext(getApolloContext());\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  var defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n\n  var _b = useState(function () {\n    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    var obsQuery = null;\n\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      obsQuery = client.watchQuery(watchQueryOptions);\n\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n      }\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery.getCurrentResult().loading) {\n      context.renderPromises.addQueryPromise({\n        getOptions: function () {\n          return createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n        },\n        fetchData: function () {\n          return new Promise(function (resolve) {\n            var sub = obsQuery.subscribe({\n              next: function (result) {\n                if (!result.loading) {\n                  resolve();\n                  sub.unsubscribe();\n                }\n              },\n              error: function () {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete: function () {\n                resolve();\n              }\n            });\n          });\n        }\n      }, function () {\n        return null;\n      });\n    }\n\n    return obsQuery;\n  }),\n      obsQuery = _b[0],\n      setObsQuery = _b[1];\n\n  var _c = useState(function () {\n    var _a, _b;\n\n    var result = obsQuery.getCurrentResult();\n\n    if (!result.loading && options) {\n      if (result.error) {\n        (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n      } else if (result.data) {\n        (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n      }\n    }\n\n    return result;\n  }),\n      result = _c[0],\n      setResult = _c[1];\n\n  var ref = useRef({\n    client: client,\n    query: query,\n    options: options,\n    result: result,\n    previousData: void 0,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions)\n  });\n  useEffect(function () {\n    var _a, _b;\n\n    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    var nextResult;\n\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      var obsQuery_1 = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery_1);\n      nextResult = obsQuery_1.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(function () {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      var previousResult = ref.current.result;\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, nextResult.error);\n        } else if (nextResult.data) {\n          (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, {\n      client: client,\n      query: query\n    });\n  }, [obsQuery, client, query, options]);\n  useEffect(function () {\n    if (context.renderPromises) {\n      return;\n    }\n\n    var subscription = obsQuery.subscribe(onNext, onError);\n\n    function onNext() {\n      var _a, _b;\n\n      var previousResult = ref.current.result;\n      var result = obsQuery.getCurrentResult();\n\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n\n      if (!result.loading) {\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n      }\n    }\n\n    function onError(error) {\n      var _a, _b;\n\n      var last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        throw error;\n      }\n\n      var previousResult = ref.current.result;\n\n      if (previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: NetworkStatus.error\n        });\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n      }\n    }\n\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n  var partial;\n  _a = result, partial = _a.partial, result = __rest(_a, [\"partial\"]);\n  {\n    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== 'cache-only') {\n      result = __assign(__assign({}, result), {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      obsQuery.refetch();\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(function () {});\n    }\n\n    Object.assign(ref.current, {\n      options: options\n    });\n  }\n\n  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n    result = ref.current.result = {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    };\n  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n    result = {\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    result = __assign(__assign({}, result), {\n      error: result.error || new ApolloError({\n        graphQLErrors: result.errors\n      })\n    });\n  }\n\n  var obsQueryFields = useMemo(function () {\n    return {\n      refetch: obsQuery.refetch.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n    };\n  }, [obsQuery]);\n  return __assign(__assign(__assign({}, obsQueryFields), {\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client: client,\n    called: true,\n    previousData: ref.current.previousData\n  }), result);\n}\n\nfunction createWatchQueryOptions(query, options, defaultOptions) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var skip = options.skip,\n      ssr = options.ssr,\n      onCompleted = options.onCompleted,\n      onError = options.onError,\n      displayName = options.displayName,\n      otherOptions = __rest(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n\n  var watchQueryOptions = __assign({\n    query: query\n  }, otherOptions);\n\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {};\n  }\n\n  return watchQueryOptions;\n}","map":{"version":3,"mappings":"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","names":["useContext","useEffect","useMemo","useRef","useState","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","useQuery","query","options","context","client","defaultWatchQueryOptions","defaultOptions","watchQuery","Query","watchQueryOptions","createWatchQueryOptions","obsQuery","renderPromises","getSSRObservable","registerSSRObservable","ssr","skip","getCurrentResult","loading","addQueryPromise","getOptions","fetchData","Promise","resolve","sub","subscribe","next","result","unsubscribe","error","complete","setObsQuery","onError","_a","data","onCompleted","_b","setResult","ref","previousData","nextResult","current","obsQuery_1","setOptions","catch","previousResult","Object","assign","subscription","onNext","networkStatus","last","resetLastResults","hasOwnProperty","disableNetworkFetches","partial","partialRefetch","keys","length","fetchPolicy","refetch","ready","errors","graphQLErrors","obsQueryFields","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","variables","called","displayName","otherOptions"],"sources":["/Users/asish/Desktop/chat app/node_modules/@apollo/src/react/hooks/useQuery.ts"],"sourcesContent":["import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables, mergeOptions } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  const defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          options.onError?.(nextResult.error);\n        } else if (nextResult.data) {\n          options.onCompleted?.(nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(() => {});\n    }\n\n    // We assign options during rendering as a guard to make sure that\n    // callbacks like onCompleted and onError are not stale.\n    Object.assign(ref.current, { options });\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\n/**\n * A function to massage options before passing them the ObservableQuery.\n */\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n  defaultOptions?: Partial<WatchQueryOptions<any, any>>\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...otherOptions\n  } = options;\n\n  let watchQueryOptions = { query, ...otherOptions };\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {} as TVariables;\n  }\n\n  return watchQueryOptions;\n}\n"]},"metadata":{},"sourceType":"module"}